#include <bits/stdc++.h>
using namespace std;

int main()
{
	
	return 0;
}


/*
先对所有的数据预处理，统计出数据的位置
然后每次插入一个数据，我们查找出它的前驱和后继
这样就能处理问题三了
那么问题二呢？
很简单，插入一个元素之后，要删除一个贡献，增加两个贡献。
第一个贡献的位置是当前位置减去上一个位置，
第二个贡献的位置是当前位置减去原数列的下一个位置的数。
上一个位置很好处理，然后插入的位置是确定的
原数列下一个位置的数也是很好确定的。
要支持可删除，我们开两个堆就可以实现了。
一个堆是插入堆另一个是删除堆。
很好处理 
*/ 
